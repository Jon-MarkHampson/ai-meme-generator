"""
Conversation management service handling chat session lifecycle.

This service manages conversation entities that group related messages and memes
together, providing context for AI interactions and user organization. Each
conversation belongs to a specific user and maintains chronological ordering.

Key responsibilities:
- Conversation CRUD operations with ownership validation
- Chronological ordering by activity for optimal user experience
- User isolation to prevent cross-user data access
- Summary management for conversation context
- Cascade deletion coordination with messages and memes

Business logic:
- Conversations are created automatically when users send their first message
- Updated timestamps track the most recent activity for sidebar ordering
- Summaries are generated by AI to help users navigate their conversation history
"""
from datetime import datetime, timezone
from typing import List, Optional
from sqlmodel import Session, select
from features.conversations.model import Conversation
from .schema import ConversationUpdate


def list_conversations(session: Session, user_id: str) -> List[Conversation]:
    """
    Retrieve all conversations for a specific user, ordered by most recent.
    
    Args:
        session: Database session for executing queries
        user_id: The ID of the user whose conversations to retrieve
        
    Returns:
        List of Conversation objects, newest first
    """
    statement = (
        select(Conversation)
        .where(Conversation.user_id == user_id)
        .order_by(Conversation.updated_at.desc())
    )
    return list(session.exec(statement).all())


def create_conversation(session: Session, user_id: str) -> Conversation:
    """
    Create a new conversation for a user.
    
    Args:
        session: Database session for executing queries
        user_id: The ID of the user creating the conversation
        
    Returns:
        The newly created Conversation object
    """
    conversation = Conversation(user_id=user_id)
    session.add(conversation)
    session.commit()
    session.refresh(conversation)  # Refresh to get generated ID and timestamps
    return conversation


def get_conversation(session: Session, conversation_id: str, user_id: str) -> Optional[Conversation]:
    """
    Retrieve a specific conversation, ensuring it belongs to the requesting user.
    
    Args:
        session: Database session for executing queries
        conversation_id: The ID of the conversation to retrieve
        user_id: The ID of the user requesting the conversation
        
    Returns:
        Conversation object if found and belongs to user, None otherwise
    """
    conversation = session.get(Conversation, conversation_id)
    # Security check: ensure the conversation belongs to the requesting user
    if conversation and conversation.user_id == user_id:
        return conversation
    return None


def update_conversation(
    session: Session,
    conversation_id: str,
    user_id: str,
    updates: ConversationUpdate
) -> Optional[Conversation]:
    """
    Update a conversation's properties (currently just summary).
    
    Args:
        session: Database session for executing queries
        conversation_id: The ID of the conversation to update
        user_id: The ID of the user requesting the update
        updates: ConversationUpdate object containing fields to update
        
    Returns:
        Updated Conversation object if found and updated, None if not found
    """
    conversation = get_conversation(session, conversation_id, user_id)
    if not conversation:
        return None
    
    # Only update fields that were explicitly provided
    if updates.summary is not None:
        conversation.summary = updates.summary
    
    # Always update the timestamp when making changes
    conversation.updated_at = datetime.now(timezone.utc)
    session.add(conversation)
    session.commit()
    session.refresh(conversation)
    return conversation


def delete_conversation(session: Session, conversation_id: str, user_id: str) -> bool:
    """
    Delete a conversation and all associated messages.
    
    Args:
        session: Database session for executing queries
        conversation_id: The ID of the conversation to delete
        user_id: The ID of the user requesting the deletion
        
    Returns:
        True if conversation was deleted, False if not found or unauthorized
    """
    conversation = get_conversation(session, conversation_id, user_id)
    if not conversation:
        return False
    
    # SQLModel will cascade delete related messages due to foreign key constraints
    session.delete(conversation)
    session.commit()
    return True